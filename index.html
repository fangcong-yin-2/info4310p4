<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <script>
        // Set the dimensions of the canvas / graph
        var margin = {
                top: 30,
                right: 20,
                bottom: 30,
                left: 50
            },
            width = 1300 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

       
        

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var chart = svg.append("g")
            .attr("id", "chart");

        const yAxisArea = svg.append("g").attr("transform",`translate(${margin.left-2},${margin.top})`);
        const xAxisArea = chart.append("g");

        var clip = svg.append("defs").append("svg:clipPath").attr("id","clip").append("svg:rect")
                        .attr("width", width).attr("height",height)
                        .attr("x",0)
                        .attr("y",0);
        var scatter = svg.append('g').attr('clip-path','url(#clip)');


        var file = "./holidays_2.csv";
        // create a function that takes in zoom and the data array; output will be data as well but with x and y
        // add x and y to each circles
        // decide size of circles, dicide cancas into a grid - only one circle can be in a grid
        // loop through data and figure out x (axis + transform)
        // loop through again from position on the board to x and y 
        // take year, convert to pixel 

        d3.csv(file).then((data) => {

            data = data.filter(d =>
                d.year_of_event !== 'NA' && Number(d.year_of_event) > 1730
            );
            
            // console.log(data)
            // Get the data
            year_data = {};
            data.forEach(function(d) {
                let year = d.year_of_event;
                if (year in year_data) {
                    year_data[Number(year)] += 1;
                } else {
                    year_data[Number(year)] = 1;
                };
            });
            let countries = [];
            for (let key in year_data){
                let countries = [];
                let country = data.filter(d => d.year_of_event == key);
                for (let i = 0; i < country.length; i++){
                    countries.push(country[i]['code'])
                }
                year_data[key][countries] = countries;
                console.log(countries);
            }



            // Scale the range of the data
            // x.domain(d3.extent(data, function(d) { return d.Value; }));
            delete year_data[0];
            let counts = Object.values(year_data);
            let count_extent = d3.extent(counts);
            let year_extent = d3.extent(Object.keys(year_data));
            // console.log([Number(year_extent[0]), Number(year_extent[1])]);


            var x = d3.scaleLinear().domain([Number(year_extent[0]), Number(year_extent[1])])
            .range([0, width]);

            var y = d3.scaleLinear().domain(count_extent)
                .range([height, 0]);

            var xAxis = svg.append("g").attr("transform", "translate(0," + (height + 5) + ")")
                            .call(d3.axisBottom(x))

            var yAxis = d3.axisLeft(y)


            // yAxisArea.append("g").attr("class", "y axis").call(yAxis);
            // xAxisArea.append("g").attr("class", "x axis").call(xAxis);

            // xAxisArea.append("g")
            //     .attr("class", "x axis")
            //     .attr("transform", "translate(0," + (height + 5) + ")")
            //     .call(xAxis)
            //     .append("text")
            //     .attr("class", "label")
            //     .attr("x", width)
            //     .attr("y", -6)
            //     .style("text-anchor", "end")
            //     .text("Day");
            /*
            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("class", "label")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("amount");
                */
            let year_json = [];
            for (let key in year_data) {
                year_json.push({
                    'year': Number(key),
                    'count': year_data[key],
                    // 'code': year_data[Code]
                });
            }
            var groups = scatter.selectAll("g.groups")
                .data(year_json)
                .enter()
                .append("g")
                .attr("transform", function(d) {
                    return "translate(" + x(d.year) + ".0)";
                });

            var dots = groups.selectAll("circle")
                .data(function(d) {
                    return d3.range(1, +d.count + 1)
                })
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 3.5)
                .attr("cy", function(d) {
                    return y(d)
                })
                .style("fill", "blue")
                .style("opacity", .5);

            var line = chart.append('line')
                            .attr('id','line')
                            .attr('y1',height)
                            .attr('y2',0)
                            .style('stroke','black')
                            .style("opacity", 0)
            line.transition().duration(750)

            var focusText = chart
                            .append('g')
                            .append('text')
                            .style("opacity", 0)
                            .attr("text-anchor", "left")
                            .attr("alignment-baseline", "middle")

            bisect = d3.bisector(year_json => year_json.year).right;


            var plotZoom = d3.zoom()
                                // .scaleExtent([0.5, 20])
                                // .extent([0,0],[width, height])
                                .on('zoom', plotZoomed);

            chart
                .append('rect')
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('width', width)
                .attr('height', height)
                .on('mouseover', mouseOver)
                .on('mousemove', mouseMove)
                .on('mouseout', mouseOut)
                .call(plotZoom);
            
            function mouseOver(){
                line.style("opacity", 1)
                focusText.style("opacity",1)
            }

            function mouseMove(e){
                let mouse = d3.pointer(e);
                let this_x = x.invert(mouse[0]);
                let i = bisect(year_json, this_x);
                let selected_d = year_json[i];
                line.attr('x1',x(selected_d.year))
                    .attr('x2',x(selected_d.year));

                focusText
                        .html(selected_d.year)
                        .attr('x',x(selected_d.year))
                        .attr('y',0)
            }

            function mouseOut(){
                line.style("opacity", 0)
                focusText.style("opacity", 0)
            }

            // pan and zoom starts here
            // var plotZoom = d3.zoom().on('zoom', plotZoomed);
            // svg.call(plotZoom);
            function plotZoomed(event) {    

                var newX = event.transform.rescaleX(x);
                xAxis.call(d3.axisBottom(newX));
                // var newY = event.transform.rescaleX(y);
                // yAxis.call(d3.axisBottom(newY));
                groups.attr("transform", function(d) {
                    return "translate(" + newX(d.year) + ".0)";
                });
                dots.selectAll("circle")
                        .attr('cy', function(d) {
                    return newX(d)
                });

                // add flags - isn't working for now
                // if(event.transform.k > 3){
                //     dots =  groups.selectAll("flags")
                //                     .data(function(d) {
                //                         return d3.range(1, +d.count + 1)
                //                     })
                //                     .enter().append("image")
                //                     .attr("xlink:href", d => {
                //                         let code = d.code
                //                         console.log(code)
                //                         return "https://flagsapi.com/" + code + "/flat/64.png";
                //                     })
                //                     .attr("class", "flags")
                //                     // .attr("r", 3.5)
                //                     .attr("y", function(d) {
                //                         return y(d)
                //                     })
                //                     // .style("fill", "blue")
                //                     // .style("opacity", .5);
                //                     .call(enter => enter.transition().attr("opacity", 1))
                // }

                // console.log(event.transform);
                // console.log(event.transform.toString());

                // chart.attr("transform", event.transform);

                // // update the scales on the axes/gridlines
                // // rescale does not modify the source scale, just creates an adjusted copy
                // // yAxis.scale(event.transform.rescaleY(y))
                // xAxis.scale(event.transform.rescaleX(x))

                // // apply new scaled axes (do not use a transition since zoom triggers so many events!)
                // d3.select("g.x.axis").call(xAxis);
                }

        });

        
    </script>
</body>

</html>