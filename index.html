<!DOCTYPE html>
<html>
<style>
    .tooltip {
        pointer-events: none;
    }
</style>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <script type="text/javascript" src="https://d3js.org/d3.v7.min.js">
    </script>
</head>

<body>
    <script>
        // Set the dimensions of the canvas / graph
        var margin = {
            top: 30,
            right: 20,
            bottom: 30,
            left: 50
        },
            width = 1300 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;




        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var chart = svg.append("g")
            .attr("id", "chart");

        const yAxisArea = svg.append("g").attr("transform", `translate(${margin.left - 2},${margin.top})`);
        const xAxisArea = chart.append("g");

        var clip = svg.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect")
            .attr("width", width).attr("height", height)
            .attr("x", 0)
            .attr("y", 0);
        var scatter = svg.append('g').attr('clip-path', 'url(#clip)');


        var file = "./holidays_new.csv";
        // create a function that takes in zoom and the data array; output will be data as well but with x and y
        // add x and y to each circles
        // decide size of circles, dicide cancas into a grid - only one circle can be in a grid
        // loop through data and figure out x (axis + transform)
        // loop through again from position on the board to x and y 
        // take year, convert to pixel 
        let dots;

        d3.csv(file).then((data) => {

            data = data.filter(d =>
                d.year_of_event !== 'NA' && Number(d.year_of_event) > 1730
            );

            // console.log(data)
            // Get the data
            year_data = {};
            data.forEach(function (d) {
                let year = Number(d.year_of_event);
                if (year in year_data) {
                    year_data[year] += 1;
                } else {
                    year_data[year] = 1;
                };
            });
            let countries = [];
            for (let key in year_data) {
                let countries = [];
                let country = data.filter(d => d.year_of_event == key);
                for (let i = 0; i < country.length; i++) {
                    countries.push(country[i]['code'])
                }
                year_data[key][countries] = countries;
            }
            let continents = ['Asia', 'Europe', 'Africa', 'North America', 'South America', 'Oceania'];
            let colorScale = d3.scaleOrdinal().domain(continents).range(d3.schemeCategory10);


            // Scale the range of the data
            // x.domain(d3.extent(data, function(d) { return d.Value; }));
            delete year_data[0];
            let counts = Object.values(year_data);
            let count_extent = d3.extent(counts);
            let year_extent = d3.extent(Object.keys(year_data));
            // console.log([Number(year_extent[0]), Number(year_extent[1])]);


            var x = d3.scaleLinear().domain([Number(year_extent[0]), Number(year_extent[1])])
                .range([0, width]);
            var y = d3.scaleLinear().domain(count_extent)
                .range([height, 0]);

            var xAxis = svg.append("g").attr("transform", "translate(0," + (height + 5) + ")")
                .call(d3.axisBottom(x))

            var yAxis = d3.axisLeft(y)


            // yAxisArea.append("g").attr("class", "y axis").call(yAxis);
            // xAxisArea.append("g").attr("class", "x axis").call(xAxis);

            // xAxisArea.append("g")
            //     .attr("class", "x axis")
            //     .attr("transform", "translate(0," + (height + 5) + ")")
            //     .call(xAxis)
            //     .append("text")
            //     .attr("class", "label")
            //     .attr("x", width)
            //     .attr("y", -6)
            //     .style("text-anchor", "end")
            //     .text("Day");
            /*
            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("class", "label")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("amount");
                */
            let year_json = [];
            for (let key in year_data) {
                year_json.push({
                    'year': Number(key),
                    'count': year_data[key],
                });
            }
            /*
            var groups = scatter.selectAll("g.groups")
                .data(year_json)
                .enter()
                .append("g")
                .attr("transform", function(d) {
                    return "translate(" + x(d.year) + ".0)";
                });

            var dots = groups.selectAll("circle")
                .data(function(d) {
                    return d3.range(1, +d.count + 1)
                })
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 3.5)
                .attr("cy", function(d) {
                    return y(d)
                })
                .style("fill", "blue")
                .style("opacity", .5);
*/

            // Create the mouseover information panel
            let tooltipWidth = 300;
            let tooltipHeight = 250;
            let tooltip = chart.append("g")
                .attr("class", "tooltip")
                .attr("visibility", "hidden");
            tooltip.append("rect")
                .attr("fill", "grey")
                .attr("opacity", 0.9)
                .attr("x", -tooltipWidth / 2.0)
                .attr("y", 0)
                .attr("width", tooltipWidth)
                .attr("height", tooltipHeight)
            let txt = tooltip.append("text")
                .attr("fill", "white")
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 2);
            let txt2 = tooltip.append("text")
                .attr("fill", "white")
                .attr("text-anchor", "right")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 22);
            let txt3 = tooltip.append("text")
                .attr("fill", "white")
                .attr("text-anchor", "right")
                .attr("alignment-baseline", "hanging")
                .attr("x", 0)
                .attr("y", 40);
            let image = tooltip.append('image')
                .attr('x', 0)
                .attr('y', 60)
            dots = scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 3.5)
                .attr("cy", function (d) {
                    return y(Number(d.stack_index)) - 3.5
                })
                .attr("transform", function (d) {
                    return "translate(" + x(Number(d.year)) + ".0)";
                })
                .attr("fill", d => colorScale(d['Continent']))
                .style("opacity", .5)
                .on('mouseover', mouseOverCircles)
                .on('mouseout', mouseOutCircles);
            var line = chart.append('line')
                .attr('id', 'line')
                .attr('y1', height)
                .attr('y2', 0)
                .style('stroke', 'black')
                .style("opacity", 0)
            line.transition().duration(750)

            var focusText = chart
                .append('g')
                .append('text')
                .style("opacity", 0)
                .attr("text-anchor", "left")
                .attr("alignment-baseline", "middle")


            bisect = d3.bisector(year_json => year_json.year).right;


            var plotZoom = d3.zoom()
                // .scaleExtent([0.5, 20])
                // .extent([0,0],[width, height])
                .on('zoom', plotZoomed);

            chart
                .append('rect')
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('width', width)
                .attr('height', height)
                .on('mouseover', mouseOver)
                .on('mousemove', mouseMove)
                .on('mouseout', mouseOut)
                .call(plotZoom);

            function mouseOver() {
                line.style("opacity", 1);
                focusText.style("opacity", 1);

            }

            function mouseOverCircles(e) {
                tooltip.style("visibility", "visible");
                // Find the state SVG element and add stroke
                let circle = d3.select(this);


                // // Original version before adding the bonus mesh after class
                // state.attr("stroke","black")
                //      .attr("stroke-width", 3);

                // Using .datum() to recover the data for the state element (because we used a .join() to make it)...
                // ... get the name of the state and count
                let circleData = circle.datum();
                console.log(circleData)

                txt.text(circleData['country']);
                txt2.text(circleData['date_mdy']);
                txt3.text('From: ' + circleData['independence_from']);
                image.attr("xlink:href", "flags/" + circleData['code'] + ".png")
                /*
                // You can use the geoPath() generator to do all sorts of helpful things 
                // let [xPos, yPos] = path.centroid( state.datum() );  // Get the pixel "center" of the state
      
                let bounds = path.bounds( state.datum() );   // Get the pixel boundaries of the state
                // In both cases here, the geoPath() is parsing the fancy topoJSON data to figure out pixels using the projection
      
                // Place it at the bottom of the state, centered
                let xPos = (bounds[0][0]+bounds[1][0])/2.0;
                let yPos = bounds[1][1] - 15;
      
                // Transform the <g> group so that everything moves together easily
                tooltip.attr("transform",`translate(${xPos},${yPos})`);*/
            }

            function mouseMove(e) {
                let mouse = d3.pointer(e);
                let this_x = x.invert(mouse[0]);
                let i = bisect(year_json, this_x);
                let selected_d = year_json[i];
                // console.log(x(selected_d.year));
                line.attr('x1', x(selected_d.year))
                    .attr('x2', x(selected_d.year));

                focusText
                    .html(selected_d.year)
                    .attr('x', x(selected_d.year))
                    .attr('y', 0)
            }

            function mouseOut() {
                line.style("opacity", 0);
                focusText.style("opacity", 0);

            }

            function mouseOutCircles() {
                tooltip.style("visibility", "hidden");
            }

            // pan and zoom starts here
            // var plotZoom = d3.zoom().on('zoom', plotZoomed);
            // svg.call(plotZoom);
            function plotZoomed(event) {
                // Do not allow zoom in if the scale is already the smallest (1 year each)
                if (event.transform.k <= 18) {

                    var newX = event.transform.rescaleX(x);
                    var newY = event.transform.rescaleY(y);
                    xAxis.call(d3.axisBottom(newX));
                    // var newY = event.transform.rescaleX(y);
                    // yAxis.call(d3.axisBottom(newY));
                    newR = Math.max(3.5, 3.5 * event.transform.k / 4);
                    // dots.attr("transform", function(d) {
                    //         return "translate(" + newX(d.year) + ")";
                    //     })
                    //     .attr("r", newR)
                    //     .attr("cy", d => y(d.stack_index) - newR);

                    // 没成功
                    // if(event.transform.k >= 3){
                    //     dots.remove();
                    //     dots = scatter.selectAll("image")
                    //             .data(data)
                    //             .join(
                    //                 enter => enter.append('image').attr("xlink:href", d => {
                    //                     let code = d.code.toLowerCase();
                    //                     console.log(code)
                    //                     return "flags/" + code + ".png";
                    //                 })
                    //                     .attr("y", d => y(d.stack_index) - newR)
                    //                     .attr("width", 20)
                    //                     .attr("height", 20)
                    //                     .attr('class', 'icons')
                    //                     .on("mouseover", mouseOver)
                    //                     .on("mouseout", mouseOut)
                    //                     .call(enter => enter.transition().attr("opacity", 1)),
                    //             );
                    // dots =  scatter.selectAll("flags")
                    //         .data(data)
                    //         .enter().append("image")
                    //         .attr("xlink:href", d => {
                    //             let code = d.code.toLowerCase();
                    //             console.log(code)
                    //             return "flags/" + code + ".png";
                    //         })
                    //         .attr("class", "flags")
                    //         // .attr("r", 3.5)
                    //         .attr("y", function(d) {
                    //             return y(d.stack_index) - newR
                    //         })
                    //         .attr()
                    //         // .style("fill", "blue")
                    //         // .style("opacity", .5);
                    //         .call(enter => enter.transition().attr("opacity", 1))
                    // }
                    // }else{
                    dots.attr("transform", function (d) {
                        return "translate(" + newX(d.year) + ")";
                    })
                        .attr("r", newR)
                        .attr("cy", d => y(d.stack_index) - newR);

                    // }


                }





            }

        });
    </script>
    <svg id="'heat_map"></svg>
    <script>
        var file = "./holidays_new.csv";
        // create a function that takes in zoom and the data array; output will be data as well but with x and y
        // add x and y to each circles
        // decide size of circles, dicide cancas into a grid - only one circle can be in a grid
        // loop through data and figure out x (axis + transform)
        // loop through again from position on the board to x and y 
        // take year, convert to pixel 
        var margin = {
            top: 30,
            right: 20,
            bottom: 30,
            left: 50
        },
            width = 1300 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;




        var heat_svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
        // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var heat_map = heat_svg.append("g")
            .attr("id", "heat_map");

        d3.csv(file).then((data) => {

            data = data.filter(d =>
                d.year_of_event !== 'NA' && Number(d.year_of_event) > 1730
            );
            // start heat map 
            date_data = {};
            abre_to_month = {
                'Jan': 1,
                'Feb': 2,
                'Mar': 3,
                'Apr': 4,
                'May': 5,
                'Jun': 6,
                'Jul': 7,
                'Aug': 8,
                'Sep': 9,
                'Oct': 10,
                'Nov': 11,
                'Dec': 12

            }
            data.forEach(function (d) {
                let date = Number(d.day);
                let month = Number(abre_to_month[d.month]);
                let year = Number(d.year_of_event);
                let date_obj = new Date(year, month - 1, date);
                if (date_obj in date_data) {
                    date_data[date_obj] += 1;
                } else {
                    date_data[date_obj] = 1;
                };
            });
            for (let key in date_data) {
                console.log(typeof key)
            }
            let heat_map_data = [];
            for (let key in date_data) {
                // console.log(typeof key)
                heat_map_data.push({
                    'date': new Date(key),
                    'count': date_data[key],
                });
            }
            heat_map_data.sort(function (a, b) { return a['date'].getTime() - b['date'].getTime() })
            console.log(heat_map_data)
            const years_heat = d3.group(heat_map_data, d => d.date.getUTCFullYear())
            const years_final = Array.from(years_heat).reverse().map(d => ({ key: d[0], values: d[1] }));
            console.log(years_final)
            // for (let value of years_heat.values()){
            //     // console.log(1111111)
            //     console.log(value)
            // }
            // for (let key of years_heat.keys()){
            //     console.log(key)
            // }
            // .key(d => d.date.getUTCFullYear())
            // .entries(date_data)
            // .reverse()
            const cellSize = 15
            const yearHeight = cellSize * 7 + 25
            const formatDay = d => ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"][d.getUTCDay()]
            const countDay = d => d.getUTCDay()
            const timeWeek = d3.utcSunday
            let year = heat_map.selectAll('g')
                .data(years_final)
                .join('g')
                .attr('transform', (d, i) => `translate(40, ${yearHeight * i + cellSize * 1.5})`)
            year.append('text')
                // .data(years_final)
                .attr('x', -5)
                .attr('y', -30)
                .attr("text-anchor", "end")
                .attr('font-size', 16)
                .attr('font-weight', 550)
                .attr('transform', 'rotate(270)')
                .text(d => d.key)
            year.append('g')
                .attr('text-anchor', 'end')
                .selectAll('text')
                .data(d3.range(7).map(i => new Date(1999, 0, i)))
                .join('text')
                .attr('x', -5)
                .attr('y', d => (countDay(d) + 0.5) * cellSize)
                .attr('dy', '0.31em')
                .text(formatDay);
            let all_dates = [];

            year.append('g')
                .selectAll('rect')
                .data(d => d.values)
                .join('rect')
                .attr("width", cellSize - 1.5)
                .attr("height", cellSize - 1.5)
                .attr("x", (d, i) => timeWeek.count(d3.utcYear(d.date), d.date) * cellSize + 10)
                .attr("y", d => countDay(d.date) * cellSize + 0.5)

            // TODO: Add colors
            const heatScale = d3.scaleSequential(d3.interpolateBuGn).domain([
                Math.floor(minValue),
                Math.ceil(maxValue)
            ])

        })
    </script>
</body>

</html>